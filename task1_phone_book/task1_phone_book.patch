diff --git a/kernel/initramfs b/kernel/initramfs
index bba9dc9eb..f60772335 100644
Binary files a/kernel/initramfs and b/kernel/initramfs differ
diff --git a/kernel/linux-6.7.4/Makefile b/kernel/linux-6.7.4/Makefile
index 73a208d9d..df8d9c412 100644
--- a/kernel/linux-6.7.4/Makefile
+++ b/kernel/linux-6.7.4/Makefile
@@ -731,7 +731,7 @@ endif
 
 ifeq ($(KBUILD_EXTMOD),)
 # Objects we will link into vmlinux / subdirs we need to visit
-core-y		:=
+core-y		:= phone_book_module/
 drivers-y	:=
 libs-y		:= lib/
 endif # KBUILD_EXTMOD
diff --git a/kernel/linux-6.7.4/arch/x86/entry/syscalls/syscall_64.tbl b/kernel/linux-6.7.4/arch/x86/entry/syscalls/syscall_64.tbl
index 8cb8bf687..55bfab5d2 100644
--- a/kernel/linux-6.7.4/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/kernel/linux-6.7.4/arch/x86/entry/syscalls/syscall_64.tbl
@@ -378,6 +378,9 @@
 454	common	futex_wake		sys_futex_wake
 455	common	futex_wait		sys_futex_wait
 456	common	futex_requeue		sys_futex_requeue
+457	64	get_pb_user		sys_get_pb_user
+458	64	add_pb_user		sys_add_pb_user
+459	64	del_pb_user		sys_del_pb_user
 
 #
 # Due to a historical design error, certain syscalls are numbered differently
diff --git a/kernel/linux-6.7.4/include/linux/syscalls.h b/kernel/linux-6.7.4/include/linux/syscalls.h
index 59fdd4074..f70827bf9 100644
--- a/kernel/linux-6.7.4/include/linux/syscalls.h
+++ b/kernel/linux-6.7.4/include/linux/syscalls.h
@@ -1280,4 +1280,12 @@ int __sys_getsockopt(int fd, int level, int optname, char __user *optval,
 		int __user *optlen);
 int __sys_setsockopt(int fd, int level, int optname, char __user *optval,
 		int optlen);
+
+struct user_data_t;
+asmlinkage long sys_get_pb_user(
+    const char __user* surname,
+struct user_data_t __user* output_data
+);
+asmlinkage long sys_add_pb_user(struct user_data_t __user* input_data);
+asmlinkage long sys_del_pb_user(const char __user* surname);
 #endif
diff --git a/kernel/linux-6.7.4/phone_book_module/CMakeLists.txt b/kernel/linux-6.7.4/phone_book_module/CMakeLists.txt
new file mode 100644
index 000000000..9e3b7db8e
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/CMakeLists.txt
@@ -0,0 +1,38 @@
+cmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)
+
+project("Linux Kernel Module with CLion IDE support / CMake" VERSION 0.1.0 LANGUAGES C)
+set(CMAKE_C_STANDARD 90)
+set(CMAKE_C_STANDARD_REQUIRED ON)
+
+# Find kernel headers
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
+find_package(KernelHeaders REQUIRED)
+
+
+# find MODULE_LICENSE("GPL"), MODULE_AUTHOR() etc.
+# thanks to "merseyviking" from stack overflow
+add_definitions(-D__KERNEL__ -DMODULE)
+
+set(COMMON_SOURCES
+        phone_book_impl.h
+        phone_book_impl.c
+        phone_book_api.h
+        phone_book_api.c
+)
+
+# this is needed in order for CLion IDE to provide syntax highlightning
+# this is independent from the actual kernel object that is built
+add_executable(phone_handbook_module
+        # add all *.h and *.c files here that # CLion should cover
+        phone_book_module_impl.c
+        ${COMMON_SOURCES}
+)
+add_executable(phone_handbook_syscall
+        phone_book.c
+        ${COMMON_SOURCES}
+)
+
+# CLion IDE will find symbols from <linux/*>
+target_include_directories("phone_handbook_module" PRIVATE ${KERNELHEADERS_INCLUDE_DIRS})
+
+target_include_directories("phone_handbook_syscall" PRIVATE ${KERNELHEADERS_INCLUDE_DIRS})
diff --git a/kernel/linux-6.7.4/phone_book_module/Makefile b/kernel/linux-6.7.4/phone_book_module/Makefile
new file mode 100644
index 000000000..bb19ee87c
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/Makefile
@@ -0,0 +1,22 @@
+obj-y += phone_book.o
+phone_book-y += \
+				phone_book_api.o \
+				phone_book_impl.o \
+
+obj-m += phone_book_module.o
+phone_book_module-y += \
+                 	phone_book_api.o \
+                 	phone_book_impl.o \
+                 	phone_book_module_impl.o \
+
+# pass it for building (default is /)
+ABS_PATH_TO_VROOT ?= "/"
+KERNEL_VERSION ?= "$(shell uname -r)"
+
+# "/lib/modules/$(shell uname -r)/build"
+PATH_TO_MODULE_BUILD=$(ABS_PATH_TO_VROOT)/lib/modules/$(KERNEL_VERSION)/build
+
+all:
+	make -C "$(PATH_TO_MODULE_BUILD)" M="$(PWD)" modules
+clean:
+	make -C "$(PATH_TO_MODULE_BUILD)" M="$(PWD)" clean
diff --git a/kernel/linux-6.7.4/phone_book_module/README.md b/kernel/linux-6.7.4/phone_book_module/README.md
new file mode 100644
index 000000000..6e4f5c05a
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/README.md
@@ -0,0 +1,78 @@
+# Device
+
+## Setup
+
+1) Install kernel with instruction in repository root.
+2) Copy `git_diff_task1.txt` to the folder where `kernel` is located.
+3) Run
+   ```bash
+   git apply git_diff_task1.txt
+   ```
+  
+    Or manually:
+    ```bash
+    # Copy
+    cd kernel/phone_book_module
+  
+    ABS_PATH_TO_VROOT=<path/to/vroot> KERNEL_VERSION=6.7.4 make clean
+    # ABS_PATH_TO_VROOT="/home/ownstreamer/Proga/MIPT/Linux/workspace/kernel/vroot" KERNEL_VERSION=6.7.4 make clean
+    ABS_PATH_TO_VROOT=<path/to/vroot> KERNEL_VERSION=6.7.4 make all
+    #ABS_PATH_TO_VROOT="/home/ownstreamer/Proga/MIPT/Linux/workspace/kernel/vroot" KERNEL_VERSION=6.7.4 make all
+    
+    cp phone_book_module.ko ../vroot/lib/modules/6.7.4/
+    
+    cd ../vroot
+    find . | cpio -ov --format=newc | gzip -9 > ../initramfs
+    
+    # Run qemu
+    cd ../
+    ```
+4) Test
+   ```bash
+    qemu-system-x86_64 -kernel ./boot/vmlinuz-6.7.4 -initrd initramfs -nographic -append "console=ttyS0"
+    ./test_module.sh
+   ```
+
+## Write options and format
+
+* Create user
+  ```bash
+  # Writ
+  echo "add name surname age phone email" > /dev/mipt_pb
+  echo "add Mike Abbot 18 +7999887766 mike.abbot@gmail.com" > /dev/mipt_pb
+  # Read
+  cat /dev/mipt_pb # User created.
+  # Result: 'User added.' or 'User already exists.'
+  ```
+
+* Find user by surname.
+  ```bash
+  # Write
+  echo "get surname" > /dev/mipt_pb
+  echo "get Abbot" > /dev/mipt_pb
+  # Read
+  cat /dev/mipt_pb
+  # Result:
+  # Name: user
+  # Surname: surname
+  # Age: age
+  # Phone: phone
+  # Email: email
+  ```
+  
+* Delete user by surname.
+  ```bash
+  # Write
+  echo "del surname" > /dev/mipt_pb
+  echo "del Abbot" > /dev/mipt_pb
+  # Read
+  cat /dev/mipt_pb
+  # Result: 'User deleted.' or 'User not found.'
+  ```
+
+* In case there are some errors in format, `cat` command will print the error.
+
+## Implementation
+
+Device has only one buffer for write and read operations. Therefore, after two write operations where will be accessible only result of the previous operation.
+
diff --git a/kernel/linux-6.7.4/phone_book_module/cmake/FindKernelHeaders.cmake b/kernel/linux-6.7.4/phone_book_module/cmake/FindKernelHeaders.cmake
new file mode 100644
index 000000000..99ac0e9be
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/cmake/FindKernelHeaders.cmake
@@ -0,0 +1,31 @@
+# BIG THANK YOU TO THE ORIGINAL AUTHOR
+# https://gitlab.com/christophacham/cmake-kernel-module
+
+# Find the kernel release
+execute_process(
+        COMMAND uname -r
+        OUTPUT_VARIABLE KERNEL_RELEASE
+        OUTPUT_STRIP_TRAILING_WHITESPACE
+)
+
+# Find the headers
+find_path(KERNELHEADERS_DIR
+        include/linux/user.h
+        PATHS /usr/src/linux-headers-${KERNEL_RELEASE}
+)
+
+message(STATUS "Kernel release: ${KERNEL_RELEASE}")
+message(STATUS "Kernel headers: ${KERNELHEADERS_DIR}")
+
+if (KERNELHEADERS_DIR)
+    set(KERNELHEADERS_INCLUDE_DIRS
+            ${KERNELHEADERS_DIR}/include
+            ${KERNELHEADERS_DIR}/arch/x86/include
+            CACHE PATH "Kernel headers include dirs"
+    )
+    set(KERNELHEADERS_FOUND 1 CACHE STRING "Set to 1 if kernel headers were found")
+else (KERNELHEADERS_DIR)
+    set(KERNELHEADERS_FOUND 0 CACHE STRING "Set to 1 if kernel headers were found")
+endif (KERNELHEADERS_DIR)
+
+mark_as_advanced(KERNELHEADERS_FOUND)
diff --git a/kernel/linux-6.7.4/phone_book_module/phone_book.c b/kernel/linux-6.7.4/phone_book_module/phone_book.c
new file mode 100644
index 000000000..d617a2e78
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/phone_book.c
@@ -0,0 +1,78 @@
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+
+#include "phone_book_api.h"
+
+/**
+ * @invariants
+ * * @b surname must be null-terminated string \n
+ * * @b output_data != NULL \n
+ * * inner fields of @b output_data must be deallocated manually by user.
+ *    User may use user_data_deep_free() from phone_book_impl() \n
+ *
+ * @param surname
+ * @param output_data
+ *
+ * @return  0 - success \n
+ *         -1 - user is not found \n
+ *         -2 - incorrect output_data \n
+ *         -3 - bad alloc \n
+ */
+//asmlinkage long sys_get_pb_user(
+//    const char __user* surname,
+//    user_data_t __user* output_data
+//) {
+//  return get_pb_user(surname, output_data);
+//}
+
+SYSCALL_DEFINE2(
+    get_pb_user,
+    const char __user *,
+    surname,
+    user_data_t __user *,
+    output_data
+) {
+return get_pb_user(surname, output_data);
+}
+EXPORT_SYMBOL(__x64_sys_get_pb_user);
+
+/**
+ *
+ * @param input_data
+ *
+ * @return  0 - success \n
+ *         -1 - user already exists \n
+ */
+//asmlinkage long sys_add_pb_user(user_data_t __user* input_data) {
+//  return add_pb_user(input_data);
+//}
+
+SYSCALL_DEFINE1(
+    add_pb_user,
+    user_data_t __user*,
+    input_data,
+){
+return add_pb_user(input_data);
+}
+
+/**
+ * @invariants
+ * @b surname must be null-terminated string \n
+ * @b user is deallocated \n
+ *
+ * @param surname
+ *
+ * @return  0 - success \n
+ *         -1 - user is not found \n
+ */
+//asmlinkage long sys_del_pb_user(const char __user* surname) {
+//  return del_pb_user(surname);
+//}
+
+SYSCALL_DEFINE1(
+    del_pb_user,
+    const char __user*,
+    surname,
+) {
+return del_pb_user(surname);
+}
diff --git a/kernel/linux-6.7.4/phone_book_module/phone_book.h b/kernel/linux-6.7.4/phone_book_module/phone_book.h
new file mode 100644
index 000000000..c18cdc099
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/phone_book.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#include <linux/kernel.h>
+
+/**
+ * @invariants
+ * * @b surname must be null-terminated string \n
+ * * @b output_data != NULL \n
+ * * inner fields of @b output_data must be deallocated manually by user.
+ *    User may use user_data_deep_free() from phone_book_impl() \n
+ *
+ * @param surname
+ * @param output_data
+ *
+ * @return  0 - success \n
+ *         -1 - user is not found \n
+ *         -2 - incorrect output_data \n
+ *         -3 - bad alloc \n
+ */
+long get_pb_user(const char* surname, struct user_data_t* output_data);
+//EXPORT_SYMBOL(get_pb_user);
+
+/**
+ *
+ * @param input_data
+ *
+ * @return  0 - success \n
+ *         -1 - user already exists \n
+ */
+long add_pb_user(struct user_data_t* input_data);
+//EXPORT_SYMBOL(add_pb_user);
+
+/**
+ * @invariants
+ * @b surname must be null-terminated string \n
+ * @b user is deallocated \n
+ *
+ * @param surname
+ *
+ * @return  0 - success \n
+ *         -1 - user is not found \n
+ */
+long del_pb_user(const char* surname);
+//EXPORT_SYMBOL(del_pb_user);
diff --git a/kernel/linux-6.7.4/phone_book_module/phone_book_api.c b/kernel/linux-6.7.4/phone_book_module/phone_book_api.c
new file mode 100644
index 000000000..400659ac2
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/phone_book_api.c
@@ -0,0 +1,66 @@
+// Other.
+#include <linux/slab.h> // kmalloc()
+
+// Local.
+#include "phone_book_api.h"
+#include "phone_book_impl.h"
+
+long get_pb_user(const char* surname, struct user_data_t* output_data) {
+  if (output_data == NULL) {
+    return -2;
+  }
+
+  user_data_impl* res = user_data_rbtree_search(&handbook.tree, surname);
+  if (res == NULL) {
+    return -1;
+  }
+
+  if (user_data_deep_copy(res->user, output_data, User) < 0) {
+    return -3;
+  }
+
+  return 0;
+}
+
+long add_pb_user(struct user_data_t* input_data) {
+  user_data_t* user = kernel_kmalloc(sizeof(user_data_t));
+  if (user_data_deep_copy(input_data, user, Kernel) < 0) {
+    goto deep_copy_failed;
+  }
+
+  user_data_impl* ud_impl = (user_data_impl*) kernel_kmalloc(sizeof(user_data_impl));
+  if (user_data_deep_copy(input_data, user, Kernel) < 0) {
+    goto user_data_impl_failed;
+  }
+
+  ud_impl->user = user;
+  long res = user_data_rbtree_insert(&handbook.tree, ud_impl);
+  if (res == -1) {
+    goto insert_failed;
+  }
+
+  return res;
+
+  insert_failed:
+  kfree(ud_impl);
+
+  user_data_impl_failed:
+  user_data_deep_free(user, Kernel);
+
+  deep_copy_failed:
+  kfree(user);
+
+  return -1;
+}
+
+long del_pb_user(const char* surname) {
+  user_data_impl* res = user_data_rbtree_search(&handbook.tree, surname);
+  if (res == NULL) {
+    return -1;
+  }
+  rb_erase(&res->node, &handbook.tree);
+  user_data_deep_free(res->user, Kernel);
+  kfree(res->user);
+  kfree(res);
+  return 0;
+}
diff --git a/kernel/linux-6.7.4/phone_book_module/phone_book_api.h b/kernel/linux-6.7.4/phone_book_module/phone_book_api.h
new file mode 100644
index 000000000..3dd0ec771
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/phone_book_api.h
@@ -0,0 +1,7 @@
+#pragma once
+
+#include "phone_book_impl.h"
+
+long get_pb_user(const char* surname, struct user_data_t* output_data);
+long add_pb_user(struct user_data_t* input_data);
+long del_pb_user(const char* surname);
diff --git a/kernel/linux-6.7.4/phone_book_module/phone_book_impl.c b/kernel/linux-6.7.4/phone_book_module/phone_book_impl.c
new file mode 100644
index 000000000..646aa6bd3
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/phone_book_impl.c
@@ -0,0 +1,154 @@
+#include "phone_book_impl.h"
+
+handbook_t handbook = {
+    .tree = RB_ROOT,
+};
+
+void init_handbook(void) {
+  handbook.tree = RB_ROOT;
+}
+
+//------------------------------------------------------------------------------
+
+// Malloc.
+
+void* kernel_kmalloc(size_t size) {
+  return kmalloc(size, GFP_KERNEL);
+}
+
+long user_data_copy_field(
+    const char* user_field,
+    const char** out_field,
+    void* malloc_func(size_t)
+) {
+  if (out_field == NULL) {
+    return -2;
+  }
+
+  size_t len = strlen(user_field);
+  char* buf = malloc_func(len + 1);
+  if (buf == NULL) {
+    return -1; // bad alloc
+  }
+
+  memcpy(buf, user_field, len);
+  buf[len] = '\0';
+  *out_field = buf;
+  return 0;
+}
+
+long user_data_deep_copy_aux(
+    const user_data_t* user,
+    user_data_t* out,
+    void* malloc_func(size_t),
+    void free_func(const void*)
+) {
+  if (out == NULL) {
+    return -2;
+  }
+
+  if (user_data_copy_field(user->name, &out->name, malloc_func) < 0) {
+    goto bad_alloc_name;
+  }
+  if (user_data_copy_field(user->surname, &out->surname, malloc_func) < 0) {
+    goto bad_alloc_surname;
+  }
+  out->age = user->age;
+  if (user_data_copy_field(user->phone, &out->phone, malloc_func) < 0) {
+    goto bad_alloc_phone;
+  }
+  if (user_data_copy_field(user->email, &out->email, malloc_func) < 0) {
+    goto bad_alloc_email;
+  }
+
+  return 0;
+
+  bad_alloc_email:
+  free_func(out->phone);
+
+  bad_alloc_phone:
+  free_func(out->surname);
+
+  bad_alloc_surname:
+  free_func(out->name);
+
+  bad_alloc_name:
+  free_func(out);
+
+  return -1;
+}
+
+long user_data_deep_copy(
+    const user_data_t* user,
+    user_data_t* out,
+    MallocType mtype
+) {
+//  if (mtype == User) {
+//    return user_data_deep_copy_aux(user, out, malloc, (void (*)(const void*)) free);
+//  }
+  return user_data_deep_copy_aux(user, out, kernel_kmalloc, kfree);
+}
+
+//------------------------------------------------------------------------------
+
+// Free.
+
+void user_data_deep_free_aux(user_data_t* user,
+                             void free_func(const void*)) {
+  free_func(user->name);
+  free_func(user->surname);
+  free_func(user->phone);
+  free_func(user->email);
+}
+
+void user_data_deep_free(user_data_t* user, MallocType mtype) {
+//  if (mtype == User) {
+//    user_data_deep_free_aux(user, (void (*)(const void*)) free);
+//  }
+  user_data_deep_free_aux(user, kfree);
+}
+
+struct user_data_impl* user_data_rbtree_search(struct rb_root* root,
+                                               const char* surname) {
+  struct rb_node* node = root->rb_node;
+
+  while (node) {
+    struct user_data_impl* data = container_of(node, user_data_impl, node);
+    int result;
+
+    result = strcmp(surname, data->user->surname);
+
+    if (result < 0)
+      node = node->rb_left;
+    else if (result > 0)
+      node = node->rb_right;
+    else
+      return data;
+  }
+  return NULL;
+}
+
+// data must be allocated on heap.
+long user_data_rbtree_insert(struct rb_root* root, user_data_impl* data) {
+  struct rb_node** new = &(root->rb_node), * parent = NULL;
+
+  /* Figure out where to put new node */
+  while (*new) {
+    user_data_impl* cur = container_of(*new, user_data_impl, node);
+    int result = strcmp(data->user->surname, cur->user->surname);
+
+    parent = *new;
+    if (result < 0)
+      new = &((*new)->rb_left);
+    else if (result > 0)
+      new = &((*new)->rb_right);
+    else
+      return -1;
+  }
+
+  /* Add new node and rebalance tree. */
+  rb_link_node(&data->node, parent, new);
+  rb_insert_color(&data->node, root);
+
+  return 0;
+}
diff --git a/kernel/linux-6.7.4/phone_book_module/phone_book_impl.h b/kernel/linux-6.7.4/phone_book_module/phone_book_impl.h
new file mode 100644
index 000000000..b339dab85
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/phone_book_impl.h
@@ -0,0 +1,81 @@
+#pragma once
+
+//#include <malloc.h>
+//#include <stddef.h>
+
+#include <linux/slab.h>
+#include <linux/rbtree.h>
+
+//------------------------------------------------------------------------------
+
+// Structures.
+
+struct user_data_t {
+  const char* name;
+  const char* surname;
+  size_t age;
+  const char* phone;
+  const char* email;
+} typedef user_data_t;
+
+struct user_data_impl {
+  struct rb_node node;
+  user_data_t* user;
+} typedef user_data_impl;
+
+struct handbook_t {
+  struct rb_root tree;
+} typedef handbook_t;
+
+extern handbook_t handbook;
+
+enum MallocType {
+  User,
+  Kernel,
+} typedef MallocType;
+
+//------------------------------------------------------------------------------
+
+// Functions.
+
+void init_handbook(void);
+
+//------------------------------------------------------------------------------
+
+// Malloc.
+void* kernel_kmalloc(size_t size);
+// 'out' must be allocated or be on stack (not NULL).
+long user_data_copy_field(
+    const char* user_field,
+    const char** out_field,
+    void* malloc_func(size_t)
+);
+long user_data_deep_copy_aux(
+    const user_data_t* user,
+    user_data_t* out,
+    void* malloc_func(size_t),
+    void free_func(const void*)
+);
+long user_data_deep_copy(
+    const user_data_t* user,
+    user_data_t* out,
+    MallocType mtype
+);
+
+//------------------------------------------------------------------------------
+
+// Free.
+
+void user_data_deep_free_aux(user_data_t* user,
+                             void free_func(const void*));
+void user_data_deep_free(user_data_t* user, MallocType mtype);
+
+//------------------------------------------------------------------------------
+
+// Rbtree.
+
+struct user_data_impl* user_data_rbtree_search(struct rb_root* root,
+                                               const char* surname);
+
+// 'data' must be kernel-allocated.
+long user_data_rbtree_insert(struct rb_root* root, user_data_impl* data);
diff --git a/kernel/linux-6.7.4/phone_book_module/phone_book_module_impl.c b/kernel/linux-6.7.4/phone_book_module/phone_book_module_impl.c
new file mode 100644
index 000000000..67be37a34
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/phone_book_module_impl.c
@@ -0,0 +1,323 @@
+// Module registration.
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+// Creation of character device.
+#include <linux/kdev_t.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+
+// Local.
+#include "phone_book_api.h"
+
+#define DEVICE_BUF_SIZE 1024
+#define COMMAND_MAX_LEN 5
+#define NAME_MAX_LEN 30
+#define SURNAME_MAX_LEN 30
+#define PHONE_MAX_LEN 15
+#define EMAIL_MAX_LEN 30
+
+//------------------------------------------------------------------------------
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Egor Vashkevich");
+MODULE_DESCRIPTION("Phone Book");
+MODULE_VERSION("0.01");
+
+static int __init mipt_phone_book_init(void);
+static void __exit mipt_phone_book_exit(void);
+
+//------------------------------------------------------------------------------
+
+// Creating character device
+
+dev_t dev = 0;
+static struct class* dev_class;
+static struct cdev mipt_cdev;
+
+//------------------------------------------------------------------------------
+
+// file_operations implementation.
+
+static int mipt_open(struct inode* inode, struct file* file);
+static int mipt_release(struct inode* inode, struct file* file);
+static ssize_t mipt_read(struct file* filp,
+                         char __user* buf,
+                         size_t len,
+                         loff_t* off);
+static ssize_t mipt_write(struct file* filp,
+                          const char* buf,
+                          size_t len,
+                          loff_t* off);
+static struct file_operations fops =
+    {
+        .owner      = THIS_MODULE,
+        .read       = mipt_read,
+        .write      = mipt_write,
+        .open       = mipt_open,
+        .release    = mipt_release,
+    };
+
+//------------------------------------------------------------------------------
+
+// Constants.
+
+// 100 is error message padding.
+static char device_buf[DEVICE_BUF_SIZE + 100 + 1] = {};
+
+static char add_cmd[] = "add";
+static char get_cmd[] = "get";
+static char del_cmd[] = "del";
+
+//------------------------------------------------------------------------------
+
+// Open & Release.
+
+static int mipt_open(struct inode* inode, struct file* filp) {
+  return 0;
+}
+
+static int mipt_release(struct inode* inode, struct file* filp) {
+  return 0;
+}
+
+//------------------------------------------------------------------------------
+
+// Read.
+
+/*
+** This function will be called when we Read the Device file
+*/
+static ssize_t mipt_read(struct file* filp,
+                         char __user* buf,
+                         size_t len,
+                         loff_t* off) {
+  if (len == 0) {
+    return 0;
+  }
+  if (len > DEVICE_BUF_SIZE - *off) {
+    len = DEVICE_BUF_SIZE - *off;
+  }
+
+  size_t msg_len = strlen(device_buf);
+  if (*off >= msg_len) {
+    return 0;
+  } else if (msg_len < len) {
+    len = msg_len;
+  }
+
+  // copy_to_user() == memcpy(), but make security checks.
+  if (copy_to_user(buf, device_buf + *off, len) != 0) {
+    return -EFAULT;
+  }
+
+  *off += (loff_t) len;
+  return (loff_t) len;
+}
+
+//------------------------------------------------------------------------------
+
+// Write.
+
+void display_user_data(user_data_t* user) {
+  sprintf(
+      device_buf,
+      "name: %s\n"
+      "surname: %s\n"
+      "age: %zu\n"
+      "phone: %s\n"
+      "email: %s\n",
+      user->name,
+      user->surname,
+      user->age,
+      user->phone,
+      user->email
+  );
+}
+
+// Write can be made gradually (therefore offset if provided to write function).
+// So parsing instruction may fail and we "try" to parse it.
+void try_parse_write_command(void) {
+  char* cmd = kernel_kmalloc(COMMAND_MAX_LEN + 1);
+
+  if (sscanf(device_buf, "%s", cmd) != 1) {
+    goto parse_fail;
+  }
+  char* cur_wb = device_buf + strlen(cmd) + 1;
+
+  if (strcmp(cmd, add_cmd) == 0) {
+    char* name = kernel_kmalloc(NAME_MAX_LEN + 1);
+    char* surname = kernel_kmalloc(SURNAME_MAX_LEN);
+    size_t age = 0;
+    char* phone = kernel_kmalloc(PHONE_MAX_LEN);
+    char* email = kernel_kmalloc(EMAIL_MAX_LEN);
+
+    if (sscanf(cur_wb,
+               "%s %s %zu %s %s",
+               name,
+               surname,
+               &age,
+               phone,
+               email) != 5) {
+      kfree(name);
+      kfree(surname);
+      kfree(phone);
+      kfree(email);
+      goto parse_fail;
+    }
+
+    user_data_t new_user = {
+      .name = name,
+      .surname = surname,
+      .age = age,
+      .phone = phone,
+      .email = email,
+    };
+    add_pb_user(&new_user);
+
+    kfree(name);
+    kfree(surname);
+    kfree(phone);
+    kfree(email);
+
+    sprintf(device_buf, "New user inserted successfully.\n");
+    goto return_with_clear;
+  }
+  if (strcmp(cmd, get_cmd) == 0) {
+    char* surname = kernel_kmalloc(SURNAME_MAX_LEN + 1);
+    if (sscanf(cur_wb, "%s", surname) != 1) {
+      kfree(surname);
+      goto parse_fail;
+    }
+
+    user_data_rbtree_search(&handbook.tree, surname);
+    user_data_impl* ud_impl = user_data_rbtree_search(&handbook.tree, surname);
+
+    if (ud_impl == NULL) {
+      sprintf(device_buf, "User not found.\n");
+      kfree(surname);
+      goto return_with_clear;
+    }
+    kfree(surname);
+
+    display_user_data(ud_impl->user);
+    goto return_with_clear;
+  }
+  if (strcmp(cmd, del_cmd) == 0) {
+    char* surname = kernel_kmalloc(SURNAME_MAX_LEN + 1);
+    if (sscanf(cur_wb, "%s", surname) != 1) {
+      kfree(surname);
+      goto parse_fail;
+    }
+
+    if (del_pb_user(surname) == -1) {
+      sprintf(device_buf, "User '%s' not found.\n", surname);
+    }
+    sprintf(device_buf, "User '%s' successfully deleted.\n", surname);
+
+    kfree(surname);
+    goto return_with_clear;
+  }
+
+  parse_fail:
+  pr_info("Parse error (probably write buffer is not fully flushed).\n"
+          "Current buffer: %s\n", device_buf);
+  char tmp_buf[DEVICE_BUF_SIZE + 1] = {};
+  strcpy(tmp_buf, device_buf);
+  sprintf(device_buf, "Parse error (probably write buffer is not fully flushed).\n"
+                      "Current buffer: %s\n", tmp_buf);
+
+  return_with_clear:
+  kfree(cmd);
+}
+
+/*
+** This function will be called when we write the Device file
+*/
+static ssize_t mipt_write(struct file* filp,
+                          const char __user* buf,
+                          size_t len,
+                          loff_t* off) {
+  if (len == 0) {
+    return 0;
+  }
+  if (*off + 1 > DEVICE_BUF_SIZE) {
+    return 0;
+  }
+  if (*off + len + 1 > DEVICE_BUF_SIZE) {
+    len = DEVICE_BUF_SIZE - *off - 1;
+  }
+  if (copy_from_user(device_buf + *off, buf, len) != 0) {
+    return -EFAULT; // address not from user process
+  }
+  device_buf[*off + len] = '\0';
+
+  try_parse_write_command();
+
+  *off += (loff_t) len;
+  return (loff_t) len;
+}
+
+//------------------------------------------------------------------------------
+
+// Module init/exit.
+
+static int __init mipt_phone_book_init(void) {
+  printk(KERN_INFO "Start inserting kernel module...");
+
+  // Allocating Major number
+  if ((alloc_chrdev_region(&dev, 0, 1, "mipt_pb")) < 0) {
+    pr_err("Cannot allocate major number for device\n");
+    return -1;
+  }
+  pr_info("Major = %d Minor = %d \n", MAJOR(dev), MINOR(dev));
+
+  // Creating cdev structure
+  cdev_init(&mipt_cdev, &fops);
+
+  // Adding character device to the system
+  if ((cdev_add(&mipt_cdev, dev, 1)) < 0) {
+    pr_err("Cannot add the device to the system\n");
+    goto r_class;
+  }
+
+  // Creating struct class
+  dev_class = class_create("mipt_pb");
+  if (IS_ERR(dev_class)) {
+    pr_err("Cannot create the struct class for device\n");
+    goto r_class;
+  }
+
+  // Creating device
+  if (IS_ERR(device_create(dev_class, NULL, dev, NULL, "mipt_pb"))) {
+    pr_err("Cannot create the Device\n");
+    goto r_device;
+  }
+
+  // Init rbtree structure.
+  init_handbook();
+
+  pr_info("Kernel module inserted successfully\n");
+  return 0;
+
+  // Clean in case there are errors.
+  r_device:
+  class_destroy(dev_class);
+  r_class:
+  unregister_chrdev_region(dev, 1);
+  return -1;
+}
+
+static void __exit mipt_phone_book_exit(void) {
+  pr_info("Start removing kernel module...\n");
+
+  device_destroy(dev_class, dev);
+  class_destroy(dev_class);
+  unregister_chrdev_region(dev, 1);
+
+  pr_info("Kernel module removed successfully\n");
+}
+
+module_init(mipt_phone_book_init)
+module_exit(mipt_phone_book_exit)
diff --git a/kernel/linux-6.7.4/phone_book_module/tests/test_module.sh b/kernel/linux-6.7.4/phone_book_module/tests/test_module.sh
new file mode 100755
index 000000000..fdca76c1f
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/tests/test_module.sh
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# Add
+echo "Test add"
+echo "add Mike Abbot 18 +7999887766 mike.abbot@gmail.com" > /dev/mipt_pb
+cat /dev/mipt_pb # User created.
+echo "--------"
+
+# Get
+echo "Test get"
+echo "get Abbot" > /dev/mipt_pb
+cat /dev/mipt_pb
+echo "--------"
+
+# Delete
+echo "Test delete"
+echo "del Abbot" > /dev/mipt_pb
+cat /dev/mipt_pb
+echo "--------"
diff --git a/kernel/linux-6.7.4/phone_book_module/tests/test_module_sys.c b/kernel/linux-6.7.4/phone_book_module/tests/test_module_sys.c
new file mode 100644
index 000000000..0128db935
--- /dev/null
+++ b/kernel/linux-6.7.4/phone_book_module/tests/test_module_sys.c
@@ -0,0 +1,34 @@
+#include <stddef.h>
+#include <unistd.h>
+
+//457	common	get_pb_user		sys_get_pb_user
+//458	common	add_pb_user		sys_add_pb_user
+//459	common	del_pb_user		sys_del_pb_user
+
+struct user_data_t {
+  const char* name;
+  const char* surname;
+  size_t age;
+  const char* phone;
+  const char* email;
+} typedef user_data_t;
+
+int main() {
+
+  user_data_t user = {
+      .name = "Mike",
+      .surname = "Abbot",
+      .age = 18,
+      .phone = "+7999887766",
+      .email = "mike.abbot@gmail.com",
+  };
+
+//  sys_add_pb_user(&user);
+  syscall(458, &user);
+
+//  sys_get_pb_user("Abbot", user);
+  syscall(457, "Abbot", user);
+
+//  sys_del_pb_user("Abbot");
+  syscall(459, "Abbot");
+}
diff --git a/kernel/phone_book_module/CMakeLists.txt b/kernel/phone_book_module/CMakeLists.txt
new file mode 100644
index 000000000..9e3b7db8e
--- /dev/null
+++ b/kernel/phone_book_module/CMakeLists.txt
@@ -0,0 +1,38 @@
+cmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)
+
+project("Linux Kernel Module with CLion IDE support / CMake" VERSION 0.1.0 LANGUAGES C)
+set(CMAKE_C_STANDARD 90)
+set(CMAKE_C_STANDARD_REQUIRED ON)
+
+# Find kernel headers
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
+find_package(KernelHeaders REQUIRED)
+
+
+# find MODULE_LICENSE("GPL"), MODULE_AUTHOR() etc.
+# thanks to "merseyviking" from stack overflow
+add_definitions(-D__KERNEL__ -DMODULE)
+
+set(COMMON_SOURCES
+        phone_book_impl.h
+        phone_book_impl.c
+        phone_book_api.h
+        phone_book_api.c
+)
+
+# this is needed in order for CLion IDE to provide syntax highlightning
+# this is independent from the actual kernel object that is built
+add_executable(phone_handbook_module
+        # add all *.h and *.c files here that # CLion should cover
+        phone_book_module_impl.c
+        ${COMMON_SOURCES}
+)
+add_executable(phone_handbook_syscall
+        phone_book.c
+        ${COMMON_SOURCES}
+)
+
+# CLion IDE will find symbols from <linux/*>
+target_include_directories("phone_handbook_module" PRIVATE ${KERNELHEADERS_INCLUDE_DIRS})
+
+target_include_directories("phone_handbook_syscall" PRIVATE ${KERNELHEADERS_INCLUDE_DIRS})
diff --git a/kernel/phone_book_module/Makefile b/kernel/phone_book_module/Makefile
new file mode 100644
index 000000000..bb19ee87c
--- /dev/null
+++ b/kernel/phone_book_module/Makefile
@@ -0,0 +1,22 @@
+obj-y += phone_book.o
+phone_book-y += \
+				phone_book_api.o \
+				phone_book_impl.o \
+
+obj-m += phone_book_module.o
+phone_book_module-y += \
+                 	phone_book_api.o \
+                 	phone_book_impl.o \
+                 	phone_book_module_impl.o \
+
+# pass it for building (default is /)
+ABS_PATH_TO_VROOT ?= "/"
+KERNEL_VERSION ?= "$(shell uname -r)"
+
+# "/lib/modules/$(shell uname -r)/build"
+PATH_TO_MODULE_BUILD=$(ABS_PATH_TO_VROOT)/lib/modules/$(KERNEL_VERSION)/build
+
+all:
+	make -C "$(PATH_TO_MODULE_BUILD)" M="$(PWD)" modules
+clean:
+	make -C "$(PATH_TO_MODULE_BUILD)" M="$(PWD)" clean
diff --git a/kernel/phone_book_module/cmake/FindKernelHeaders.cmake b/kernel/phone_book_module/cmake/FindKernelHeaders.cmake
new file mode 100644
index 000000000..99ac0e9be
--- /dev/null
+++ b/kernel/phone_book_module/cmake/FindKernelHeaders.cmake
@@ -0,0 +1,31 @@
+# BIG THANK YOU TO THE ORIGINAL AUTHOR
+# https://gitlab.com/christophacham/cmake-kernel-module
+
+# Find the kernel release
+execute_process(
+        COMMAND uname -r
+        OUTPUT_VARIABLE KERNEL_RELEASE
+        OUTPUT_STRIP_TRAILING_WHITESPACE
+)
+
+# Find the headers
+find_path(KERNELHEADERS_DIR
+        include/linux/user.h
+        PATHS /usr/src/linux-headers-${KERNEL_RELEASE}
+)
+
+message(STATUS "Kernel release: ${KERNEL_RELEASE}")
+message(STATUS "Kernel headers: ${KERNELHEADERS_DIR}")
+
+if (KERNELHEADERS_DIR)
+    set(KERNELHEADERS_INCLUDE_DIRS
+            ${KERNELHEADERS_DIR}/include
+            ${KERNELHEADERS_DIR}/arch/x86/include
+            CACHE PATH "Kernel headers include dirs"
+    )
+    set(KERNELHEADERS_FOUND 1 CACHE STRING "Set to 1 if kernel headers were found")
+else (KERNELHEADERS_DIR)
+    set(KERNELHEADERS_FOUND 0 CACHE STRING "Set to 1 if kernel headers were found")
+endif (KERNELHEADERS_DIR)
+
+mark_as_advanced(KERNELHEADERS_FOUND)
diff --git a/kernel/phone_book_module/phone_book.c b/kernel/phone_book_module/phone_book.c
new file mode 100644
index 000000000..1fc66eb11
--- /dev/null
+++ b/kernel/phone_book_module/phone_book.c
@@ -0,0 +1,77 @@
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+
+#include "phone_book_api.h"
+
+/**
+ * @invariants
+ * * @b surname must be null-terminated string \n
+ * * @b output_data != NULL \n
+ * * inner fields of @b output_data must be deallocated manually by user.
+ *    User may use user_data_deep_free() from phone_book_impl() \n
+ *
+ * @param surname
+ * @param output_data
+ *
+ * @return  0 - success \n
+ *         -1 - user is not found \n
+ *         -2 - incorrect output_data \n
+ *         -3 - bad alloc \n
+ */
+//asmlinkage long sys_get_pb_user(
+//    const char __user* surname,
+//    user_data_t __user* output_data
+//) {
+//  return get_pb_user(surname, output_data);
+//}
+
+SYSCALL_DEFINE2(
+    get_pb_user,
+    const char __user *,
+    surname,
+    user_data_t __user *,
+    output_data
+) {
+return get_pb_user(surname, output_data);
+}
+
+/**
+ *
+ * @param input_data
+ *
+ * @return  0 - success \n
+ *         -1 - user already exists \n
+ */
+//asmlinkage long sys_add_pb_user(user_data_t __user* input_data) {
+//  return add_pb_user(input_data);
+//}
+
+SYSCALL_DEFINE1(
+    add_pb_user,
+    user_data_t __user*,
+    input_data,
+){
+return add_pb_user(input_data);
+}
+
+/**
+ * @invariants
+ * @b surname must be null-terminated string \n
+ * @b user is deallocated \n
+ *
+ * @param surname
+ *
+ * @return  0 - success \n
+ *         -1 - user is not found \n
+ */
+//asmlinkage long sys_del_pb_user(const char __user* surname) {
+//  return del_pb_user(surname);
+//}
+
+SYSCALL_DEFINE1(
+    del_pb_user,
+    const char __user*,
+    surname,
+) {
+return del_pb_user(surname);
+}
diff --git a/kernel/phone_book_module/phone_book_api.c b/kernel/phone_book_module/phone_book_api.c
new file mode 100644
index 000000000..400659ac2
--- /dev/null
+++ b/kernel/phone_book_module/phone_book_api.c
@@ -0,0 +1,66 @@
+// Other.
+#include <linux/slab.h> // kmalloc()
+
+// Local.
+#include "phone_book_api.h"
+#include "phone_book_impl.h"
+
+long get_pb_user(const char* surname, struct user_data_t* output_data) {
+  if (output_data == NULL) {
+    return -2;
+  }
+
+  user_data_impl* res = user_data_rbtree_search(&handbook.tree, surname);
+  if (res == NULL) {
+    return -1;
+  }
+
+  if (user_data_deep_copy(res->user, output_data, User) < 0) {
+    return -3;
+  }
+
+  return 0;
+}
+
+long add_pb_user(struct user_data_t* input_data) {
+  user_data_t* user = kernel_kmalloc(sizeof(user_data_t));
+  if (user_data_deep_copy(input_data, user, Kernel) < 0) {
+    goto deep_copy_failed;
+  }
+
+  user_data_impl* ud_impl = (user_data_impl*) kernel_kmalloc(sizeof(user_data_impl));
+  if (user_data_deep_copy(input_data, user, Kernel) < 0) {
+    goto user_data_impl_failed;
+  }
+
+  ud_impl->user = user;
+  long res = user_data_rbtree_insert(&handbook.tree, ud_impl);
+  if (res == -1) {
+    goto insert_failed;
+  }
+
+  return res;
+
+  insert_failed:
+  kfree(ud_impl);
+
+  user_data_impl_failed:
+  user_data_deep_free(user, Kernel);
+
+  deep_copy_failed:
+  kfree(user);
+
+  return -1;
+}
+
+long del_pb_user(const char* surname) {
+  user_data_impl* res = user_data_rbtree_search(&handbook.tree, surname);
+  if (res == NULL) {
+    return -1;
+  }
+  rb_erase(&res->node, &handbook.tree);
+  user_data_deep_free(res->user, Kernel);
+  kfree(res->user);
+  kfree(res);
+  return 0;
+}
diff --git a/kernel/phone_book_module/phone_book_api.h b/kernel/phone_book_module/phone_book_api.h
new file mode 100644
index 000000000..3dd0ec771
--- /dev/null
+++ b/kernel/phone_book_module/phone_book_api.h
@@ -0,0 +1,7 @@
+#pragma once
+
+#include "phone_book_impl.h"
+
+long get_pb_user(const char* surname, struct user_data_t* output_data);
+long add_pb_user(struct user_data_t* input_data);
+long del_pb_user(const char* surname);
diff --git a/kernel/phone_book_module/phone_book_impl.c b/kernel/phone_book_module/phone_book_impl.c
new file mode 100644
index 000000000..646aa6bd3
--- /dev/null
+++ b/kernel/phone_book_module/phone_book_impl.c
@@ -0,0 +1,154 @@
+#include "phone_book_impl.h"
+
+handbook_t handbook = {
+    .tree = RB_ROOT,
+};
+
+void init_handbook(void) {
+  handbook.tree = RB_ROOT;
+}
+
+//------------------------------------------------------------------------------
+
+// Malloc.
+
+void* kernel_kmalloc(size_t size) {
+  return kmalloc(size, GFP_KERNEL);
+}
+
+long user_data_copy_field(
+    const char* user_field,
+    const char** out_field,
+    void* malloc_func(size_t)
+) {
+  if (out_field == NULL) {
+    return -2;
+  }
+
+  size_t len = strlen(user_field);
+  char* buf = malloc_func(len + 1);
+  if (buf == NULL) {
+    return -1; // bad alloc
+  }
+
+  memcpy(buf, user_field, len);
+  buf[len] = '\0';
+  *out_field = buf;
+  return 0;
+}
+
+long user_data_deep_copy_aux(
+    const user_data_t* user,
+    user_data_t* out,
+    void* malloc_func(size_t),
+    void free_func(const void*)
+) {
+  if (out == NULL) {
+    return -2;
+  }
+
+  if (user_data_copy_field(user->name, &out->name, malloc_func) < 0) {
+    goto bad_alloc_name;
+  }
+  if (user_data_copy_field(user->surname, &out->surname, malloc_func) < 0) {
+    goto bad_alloc_surname;
+  }
+  out->age = user->age;
+  if (user_data_copy_field(user->phone, &out->phone, malloc_func) < 0) {
+    goto bad_alloc_phone;
+  }
+  if (user_data_copy_field(user->email, &out->email, malloc_func) < 0) {
+    goto bad_alloc_email;
+  }
+
+  return 0;
+
+  bad_alloc_email:
+  free_func(out->phone);
+
+  bad_alloc_phone:
+  free_func(out->surname);
+
+  bad_alloc_surname:
+  free_func(out->name);
+
+  bad_alloc_name:
+  free_func(out);
+
+  return -1;
+}
+
+long user_data_deep_copy(
+    const user_data_t* user,
+    user_data_t* out,
+    MallocType mtype
+) {
+//  if (mtype == User) {
+//    return user_data_deep_copy_aux(user, out, malloc, (void (*)(const void*)) free);
+//  }
+  return user_data_deep_copy_aux(user, out, kernel_kmalloc, kfree);
+}
+
+//------------------------------------------------------------------------------
+
+// Free.
+
+void user_data_deep_free_aux(user_data_t* user,
+                             void free_func(const void*)) {
+  free_func(user->name);
+  free_func(user->surname);
+  free_func(user->phone);
+  free_func(user->email);
+}
+
+void user_data_deep_free(user_data_t* user, MallocType mtype) {
+//  if (mtype == User) {
+//    user_data_deep_free_aux(user, (void (*)(const void*)) free);
+//  }
+  user_data_deep_free_aux(user, kfree);
+}
+
+struct user_data_impl* user_data_rbtree_search(struct rb_root* root,
+                                               const char* surname) {
+  struct rb_node* node = root->rb_node;
+
+  while (node) {
+    struct user_data_impl* data = container_of(node, user_data_impl, node);
+    int result;
+
+    result = strcmp(surname, data->user->surname);
+
+    if (result < 0)
+      node = node->rb_left;
+    else if (result > 0)
+      node = node->rb_right;
+    else
+      return data;
+  }
+  return NULL;
+}
+
+// data must be allocated on heap.
+long user_data_rbtree_insert(struct rb_root* root, user_data_impl* data) {
+  struct rb_node** new = &(root->rb_node), * parent = NULL;
+
+  /* Figure out where to put new node */
+  while (*new) {
+    user_data_impl* cur = container_of(*new, user_data_impl, node);
+    int result = strcmp(data->user->surname, cur->user->surname);
+
+    parent = *new;
+    if (result < 0)
+      new = &((*new)->rb_left);
+    else if (result > 0)
+      new = &((*new)->rb_right);
+    else
+      return -1;
+  }
+
+  /* Add new node and rebalance tree. */
+  rb_link_node(&data->node, parent, new);
+  rb_insert_color(&data->node, root);
+
+  return 0;
+}
diff --git a/kernel/phone_book_module/phone_book_impl.h b/kernel/phone_book_module/phone_book_impl.h
new file mode 100644
index 000000000..b339dab85
--- /dev/null
+++ b/kernel/phone_book_module/phone_book_impl.h
@@ -0,0 +1,81 @@
+#pragma once
+
+//#include <malloc.h>
+//#include <stddef.h>
+
+#include <linux/slab.h>
+#include <linux/rbtree.h>
+
+//------------------------------------------------------------------------------
+
+// Structures.
+
+struct user_data_t {
+  const char* name;
+  const char* surname;
+  size_t age;
+  const char* phone;
+  const char* email;
+} typedef user_data_t;
+
+struct user_data_impl {
+  struct rb_node node;
+  user_data_t* user;
+} typedef user_data_impl;
+
+struct handbook_t {
+  struct rb_root tree;
+} typedef handbook_t;
+
+extern handbook_t handbook;
+
+enum MallocType {
+  User,
+  Kernel,
+} typedef MallocType;
+
+//------------------------------------------------------------------------------
+
+// Functions.
+
+void init_handbook(void);
+
+//------------------------------------------------------------------------------
+
+// Malloc.
+void* kernel_kmalloc(size_t size);
+// 'out' must be allocated or be on stack (not NULL).
+long user_data_copy_field(
+    const char* user_field,
+    const char** out_field,
+    void* malloc_func(size_t)
+);
+long user_data_deep_copy_aux(
+    const user_data_t* user,
+    user_data_t* out,
+    void* malloc_func(size_t),
+    void free_func(const void*)
+);
+long user_data_deep_copy(
+    const user_data_t* user,
+    user_data_t* out,
+    MallocType mtype
+);
+
+//------------------------------------------------------------------------------
+
+// Free.
+
+void user_data_deep_free_aux(user_data_t* user,
+                             void free_func(const void*));
+void user_data_deep_free(user_data_t* user, MallocType mtype);
+
+//------------------------------------------------------------------------------
+
+// Rbtree.
+
+struct user_data_impl* user_data_rbtree_search(struct rb_root* root,
+                                               const char* surname);
+
+// 'data' must be kernel-allocated.
+long user_data_rbtree_insert(struct rb_root* root, user_data_impl* data);
diff --git a/kernel/phone_book_module/phone_book_module_impl.c b/kernel/phone_book_module/phone_book_module_impl.c
new file mode 100644
index 000000000..67be37a34
--- /dev/null
+++ b/kernel/phone_book_module/phone_book_module_impl.c
@@ -0,0 +1,323 @@
+// Module registration.
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+// Creation of character device.
+#include <linux/kdev_t.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+
+// Local.
+#include "phone_book_api.h"
+
+#define DEVICE_BUF_SIZE 1024
+#define COMMAND_MAX_LEN 5
+#define NAME_MAX_LEN 30
+#define SURNAME_MAX_LEN 30
+#define PHONE_MAX_LEN 15
+#define EMAIL_MAX_LEN 30
+
+//------------------------------------------------------------------------------
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Egor Vashkevich");
+MODULE_DESCRIPTION("Phone Book");
+MODULE_VERSION("0.01");
+
+static int __init mipt_phone_book_init(void);
+static void __exit mipt_phone_book_exit(void);
+
+//------------------------------------------------------------------------------
+
+// Creating character device
+
+dev_t dev = 0;
+static struct class* dev_class;
+static struct cdev mipt_cdev;
+
+//------------------------------------------------------------------------------
+
+// file_operations implementation.
+
+static int mipt_open(struct inode* inode, struct file* file);
+static int mipt_release(struct inode* inode, struct file* file);
+static ssize_t mipt_read(struct file* filp,
+                         char __user* buf,
+                         size_t len,
+                         loff_t* off);
+static ssize_t mipt_write(struct file* filp,
+                          const char* buf,
+                          size_t len,
+                          loff_t* off);
+static struct file_operations fops =
+    {
+        .owner      = THIS_MODULE,
+        .read       = mipt_read,
+        .write      = mipt_write,
+        .open       = mipt_open,
+        .release    = mipt_release,
+    };
+
+//------------------------------------------------------------------------------
+
+// Constants.
+
+// 100 is error message padding.
+static char device_buf[DEVICE_BUF_SIZE + 100 + 1] = {};
+
+static char add_cmd[] = "add";
+static char get_cmd[] = "get";
+static char del_cmd[] = "del";
+
+//------------------------------------------------------------------------------
+
+// Open & Release.
+
+static int mipt_open(struct inode* inode, struct file* filp) {
+  return 0;
+}
+
+static int mipt_release(struct inode* inode, struct file* filp) {
+  return 0;
+}
+
+//------------------------------------------------------------------------------
+
+// Read.
+
+/*
+** This function will be called when we Read the Device file
+*/
+static ssize_t mipt_read(struct file* filp,
+                         char __user* buf,
+                         size_t len,
+                         loff_t* off) {
+  if (len == 0) {
+    return 0;
+  }
+  if (len > DEVICE_BUF_SIZE - *off) {
+    len = DEVICE_BUF_SIZE - *off;
+  }
+
+  size_t msg_len = strlen(device_buf);
+  if (*off >= msg_len) {
+    return 0;
+  } else if (msg_len < len) {
+    len = msg_len;
+  }
+
+  // copy_to_user() == memcpy(), but make security checks.
+  if (copy_to_user(buf, device_buf + *off, len) != 0) {
+    return -EFAULT;
+  }
+
+  *off += (loff_t) len;
+  return (loff_t) len;
+}
+
+//------------------------------------------------------------------------------
+
+// Write.
+
+void display_user_data(user_data_t* user) {
+  sprintf(
+      device_buf,
+      "name: %s\n"
+      "surname: %s\n"
+      "age: %zu\n"
+      "phone: %s\n"
+      "email: %s\n",
+      user->name,
+      user->surname,
+      user->age,
+      user->phone,
+      user->email
+  );
+}
+
+// Write can be made gradually (therefore offset if provided to write function).
+// So parsing instruction may fail and we "try" to parse it.
+void try_parse_write_command(void) {
+  char* cmd = kernel_kmalloc(COMMAND_MAX_LEN + 1);
+
+  if (sscanf(device_buf, "%s", cmd) != 1) {
+    goto parse_fail;
+  }
+  char* cur_wb = device_buf + strlen(cmd) + 1;
+
+  if (strcmp(cmd, add_cmd) == 0) {
+    char* name = kernel_kmalloc(NAME_MAX_LEN + 1);
+    char* surname = kernel_kmalloc(SURNAME_MAX_LEN);
+    size_t age = 0;
+    char* phone = kernel_kmalloc(PHONE_MAX_LEN);
+    char* email = kernel_kmalloc(EMAIL_MAX_LEN);
+
+    if (sscanf(cur_wb,
+               "%s %s %zu %s %s",
+               name,
+               surname,
+               &age,
+               phone,
+               email) != 5) {
+      kfree(name);
+      kfree(surname);
+      kfree(phone);
+      kfree(email);
+      goto parse_fail;
+    }
+
+    user_data_t new_user = {
+      .name = name,
+      .surname = surname,
+      .age = age,
+      .phone = phone,
+      .email = email,
+    };
+    add_pb_user(&new_user);
+
+    kfree(name);
+    kfree(surname);
+    kfree(phone);
+    kfree(email);
+
+    sprintf(device_buf, "New user inserted successfully.\n");
+    goto return_with_clear;
+  }
+  if (strcmp(cmd, get_cmd) == 0) {
+    char* surname = kernel_kmalloc(SURNAME_MAX_LEN + 1);
+    if (sscanf(cur_wb, "%s", surname) != 1) {
+      kfree(surname);
+      goto parse_fail;
+    }
+
+    user_data_rbtree_search(&handbook.tree, surname);
+    user_data_impl* ud_impl = user_data_rbtree_search(&handbook.tree, surname);
+
+    if (ud_impl == NULL) {
+      sprintf(device_buf, "User not found.\n");
+      kfree(surname);
+      goto return_with_clear;
+    }
+    kfree(surname);
+
+    display_user_data(ud_impl->user);
+    goto return_with_clear;
+  }
+  if (strcmp(cmd, del_cmd) == 0) {
+    char* surname = kernel_kmalloc(SURNAME_MAX_LEN + 1);
+    if (sscanf(cur_wb, "%s", surname) != 1) {
+      kfree(surname);
+      goto parse_fail;
+    }
+
+    if (del_pb_user(surname) == -1) {
+      sprintf(device_buf, "User '%s' not found.\n", surname);
+    }
+    sprintf(device_buf, "User '%s' successfully deleted.\n", surname);
+
+    kfree(surname);
+    goto return_with_clear;
+  }
+
+  parse_fail:
+  pr_info("Parse error (probably write buffer is not fully flushed).\n"
+          "Current buffer: %s\n", device_buf);
+  char tmp_buf[DEVICE_BUF_SIZE + 1] = {};
+  strcpy(tmp_buf, device_buf);
+  sprintf(device_buf, "Parse error (probably write buffer is not fully flushed).\n"
+                      "Current buffer: %s\n", tmp_buf);
+
+  return_with_clear:
+  kfree(cmd);
+}
+
+/*
+** This function will be called when we write the Device file
+*/
+static ssize_t mipt_write(struct file* filp,
+                          const char __user* buf,
+                          size_t len,
+                          loff_t* off) {
+  if (len == 0) {
+    return 0;
+  }
+  if (*off + 1 > DEVICE_BUF_SIZE) {
+    return 0;
+  }
+  if (*off + len + 1 > DEVICE_BUF_SIZE) {
+    len = DEVICE_BUF_SIZE - *off - 1;
+  }
+  if (copy_from_user(device_buf + *off, buf, len) != 0) {
+    return -EFAULT; // address not from user process
+  }
+  device_buf[*off + len] = '\0';
+
+  try_parse_write_command();
+
+  *off += (loff_t) len;
+  return (loff_t) len;
+}
+
+//------------------------------------------------------------------------------
+
+// Module init/exit.
+
+static int __init mipt_phone_book_init(void) {
+  printk(KERN_INFO "Start inserting kernel module...");
+
+  // Allocating Major number
+  if ((alloc_chrdev_region(&dev, 0, 1, "mipt_pb")) < 0) {
+    pr_err("Cannot allocate major number for device\n");
+    return -1;
+  }
+  pr_info("Major = %d Minor = %d \n", MAJOR(dev), MINOR(dev));
+
+  // Creating cdev structure
+  cdev_init(&mipt_cdev, &fops);
+
+  // Adding character device to the system
+  if ((cdev_add(&mipt_cdev, dev, 1)) < 0) {
+    pr_err("Cannot add the device to the system\n");
+    goto r_class;
+  }
+
+  // Creating struct class
+  dev_class = class_create("mipt_pb");
+  if (IS_ERR(dev_class)) {
+    pr_err("Cannot create the struct class for device\n");
+    goto r_class;
+  }
+
+  // Creating device
+  if (IS_ERR(device_create(dev_class, NULL, dev, NULL, "mipt_pb"))) {
+    pr_err("Cannot create the Device\n");
+    goto r_device;
+  }
+
+  // Init rbtree structure.
+  init_handbook();
+
+  pr_info("Kernel module inserted successfully\n");
+  return 0;
+
+  // Clean in case there are errors.
+  r_device:
+  class_destroy(dev_class);
+  r_class:
+  unregister_chrdev_region(dev, 1);
+  return -1;
+}
+
+static void __exit mipt_phone_book_exit(void) {
+  pr_info("Start removing kernel module...\n");
+
+  device_destroy(dev_class, dev);
+  class_destroy(dev_class);
+  unregister_chrdev_region(dev, 1);
+
+  pr_info("Kernel module removed successfully\n");
+}
+
+module_init(mipt_phone_book_init)
+module_exit(mipt_phone_book_exit)
diff --git a/kernel/phone_book_module/tests/test_module.sh b/kernel/phone_book_module/tests/test_module.sh
new file mode 100755
index 000000000..fdca76c1f
--- /dev/null
+++ b/kernel/phone_book_module/tests/test_module.sh
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# Add
+echo "Test add"
+echo "add Mike Abbot 18 +7999887766 mike.abbot@gmail.com" > /dev/mipt_pb
+cat /dev/mipt_pb # User created.
+echo "--------"
+
+# Get
+echo "Test get"
+echo "get Abbot" > /dev/mipt_pb
+cat /dev/mipt_pb
+echo "--------"
+
+# Delete
+echo "Test delete"
+echo "del Abbot" > /dev/mipt_pb
+cat /dev/mipt_pb
+echo "--------"
diff --git a/kernel/phone_book_module/tests/test_module_sys.c b/kernel/phone_book_module/tests/test_module_sys.c
new file mode 100644
index 000000000..0128db935
--- /dev/null
+++ b/kernel/phone_book_module/tests/test_module_sys.c
@@ -0,0 +1,34 @@
+#include <stddef.h>
+#include <unistd.h>
+
+//457	common	get_pb_user		sys_get_pb_user
+//458	common	add_pb_user		sys_add_pb_user
+//459	common	del_pb_user		sys_del_pb_user
+
+struct user_data_t {
+  const char* name;
+  const char* surname;
+  size_t age;
+  const char* phone;
+  const char* email;
+} typedef user_data_t;
+
+int main() {
+
+  user_data_t user = {
+      .name = "Mike",
+      .surname = "Abbot",
+      .age = 18,
+      .phone = "+7999887766",
+      .email = "mike.abbot@gmail.com",
+  };
+
+//  sys_add_pb_user(&user);
+  syscall(458, &user);
+
+//  sys_get_pb_user("Abbot", user);
+  syscall(457, "Abbot", user);
+
+//  sys_del_pb_user("Abbot");
+  syscall(459, "Abbot");
+}
diff --git a/kernel/run_task1.sh b/kernel/run_task1.sh
new file mode 100755
index 000000000..6e5ff4d49
--- /dev/null
+++ b/kernel/run_task1.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+cd phone_book_module
+ABS_PATH_TO_VROOT="/home/ownstreamer/Proga/MIPT/Linux/workspace/kernel/vroot" KERNEL_VERSION=6.7.4 make clean
+ABS_PATH_TO_VROOT="/home/ownstreamer/Proga/MIPT/Linux/workspace/kernel/vroot" KERNEL_VERSION=6.7.4 make all || exit 10
+
+cp phone_book_module.ko ../vroot/lib/modules/6.7.4/
+
+cd ../vroot
+find . | cpio -ov --format=newc | gzip -9 > ../initramfs
+
+# Run qemu
+cd ../
diff --git a/kernel/vroot/init b/kernel/vroot/init
index b1f6ccfad..fbccc8c0e 100755
--- a/kernel/vroot/init
+++ b/kernel/vroot/init
@@ -7,4 +7,6 @@ mount -t sysfs sysfs /sys
 
 echo 0 > /proc/sys/kernel/printk
 
+insmod /lib/modules/6.7.4/phone_book_module.ko
+
 exec setsid sh -c 'exec sh </dev/ttyS0 >/dev/ttyS0 2>&1'
diff --git a/kernel/vroot/lib/modules/6.7.4/phone_book_module.ko b/kernel/vroot/lib/modules/6.7.4/phone_book_module.ko
index 92df85d56..4cf94f32a 100644
Binary files a/kernel/vroot/lib/modules/6.7.4/phone_book_module.ko and b/kernel/vroot/lib/modules/6.7.4/phone_book_module.ko differ
diff --git a/kernel/vroot/test_module.sh b/kernel/vroot/test_module.sh
new file mode 100755
index 000000000..fdca76c1f
--- /dev/null
+++ b/kernel/vroot/test_module.sh
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# Add
+echo "Test add"
+echo "add Mike Abbot 18 +7999887766 mike.abbot@gmail.com" > /dev/mipt_pb
+cat /dev/mipt_pb # User created.
+echo "--------"
+
+# Get
+echo "Test get"
+echo "get Abbot" > /dev/mipt_pb
+cat /dev/mipt_pb
+echo "--------"
+
+# Delete
+echo "Test delete"
+echo "del Abbot" > /dev/mipt_pb
+cat /dev/mipt_pb
+echo "--------"
diff --git a/kernel/vroot/test_module_sys.c b/kernel/vroot/test_module_sys.c
new file mode 100644
index 000000000..0128db935
--- /dev/null
+++ b/kernel/vroot/test_module_sys.c
@@ -0,0 +1,34 @@
+#include <stddef.h>
+#include <unistd.h>
+
+//457	common	get_pb_user		sys_get_pb_user
+//458	common	add_pb_user		sys_add_pb_user
+//459	common	del_pb_user		sys_del_pb_user
+
+struct user_data_t {
+  const char* name;
+  const char* surname;
+  size_t age;
+  const char* phone;
+  const char* email;
+} typedef user_data_t;
+
+int main() {
+
+  user_data_t user = {
+      .name = "Mike",
+      .surname = "Abbot",
+      .age = 18,
+      .phone = "+7999887766",
+      .email = "mike.abbot@gmail.com",
+  };
+
+//  sys_add_pb_user(&user);
+  syscall(458, &user);
+
+//  sys_get_pb_user("Abbot", user);
+  syscall(457, "Abbot", user);
+
+//  sys_del_pb_user("Abbot");
+  syscall(459, "Abbot");
+}
